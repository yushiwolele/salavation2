# -*- coding: utf-8 -*-            
# @Author : libeijie
# @Time : 2023/11/7 13:50

import logging
from CustomLibrary.dbConn import test_conn_sqlite_db

class SQLiteOpetating():
    def test_query_from_sqlitedb1(self, db_file_path):
        '''
        for test by lbj
        :param db_file_path:
        :return:
        '''
        print("!!!test_query_from_sqlitedb1test_query_from_sqlitedb1test_query_from_sqlitedb1test_query_from_sqlitedb1test_query_from_sqlitedb1!!!")
        dbconn = test_conn_sqlite_db(db_file_path)
        cursor = dbconn.cursor()  # 如果套件是流程类，则测试数据从COMMON_FLOW表中获取;否则从功能编号对应的表中获取
        select_sql = "select * from \"ZXX_0012_0005\" where SuiteName = '静态类' and TestCaseName = '检查功能页数据时段'"
        print(select_sql)
        query_result_cursor = cursor.execute(select_sql)
        query_result_list = list(query_result_cursor)
        if len(query_result_list) == 1:
            query_result = list(query_result_list[0])  # 取列表中的第1个值
            print(query_result)
        dbconn.commit()
        dbconn.close()



    def test_query_from_sqlitedb(self, db_file_path, functionID, suiteName, testcaseName):
            print("aaaaaaaaaaaaaaaaaaaaaaaaaaaaa")
            dbconn = test_conn_sqlite_db(db_file_path)
            cursor = dbconn.cursor()  # 如果套件是流程类，则测试数据从COMMON_FLOW表中获取;否则从功能编号对应的表中获取
            select_sql = 'select * from {0} where SuiteName = "{1}" and TestCaseName = "{2}"'.format(functionID,suiteName,suiteName)
            print(select_sql)
            query_result_cursor = cursor.execute(select_sql)
            query_result_list = list(query_result_cursor)  # 将行完的查询结果转成Lst(当有多条返回结果时，每个元素对应一条记录)# query_result = list(query_result cursor)[0]# # 获取当前套件的常量字典# cons_dict = self.  test_query_from_sqlitedb_cons(db_filepath, functionID, suiteName
            if len(query_result_list) == 1:
                query_result = list(query_result_list[0]) # 取列表中的第1个值
                query_result = query_result[2:]
                # query_result = [i for i in query_result if i !=] #删除列表中的空信
                for index,item in enumerate(query_result):
                    value = self.cons_replace(item, db_file_path, functionID, suiteName)
                    query_result[index] = value
                print("================若返回结果中含有没有替换成功的关键字，请检查“常量表(CONSTANT)”中是否有定义!!!============")
                return query_result
            else:
                logging.error('查询结果不唯一或为空')
            dbconn.commit()
            dbconn.close()

    def cons_replace(self, cons_key, db_file_path, functionID, suiteName):
        cons_dict = self.__test_query_from_sqlitedb_cons(db_file_path, functionID, suiteName)
        for index, key in enumerate(cons_dict):
            if key in cons_key:
                reg = r'^\d{4}-\d{1,2}-\d{1,2}'  # 日期格式 (YYYY-MM-DD)的正则表达式
                if '-' in cons_key:  # 当操作符包含在值cons_key时，则说明需要进行计算过程
                    operand1 = (cons_key.split ('-') [0]).replace (key, cons_dict[key])
                    operand2 = cons_key.split('-')[1]
                    if re.search(reg,operand1):  #若操作符前的值为日期格式时，需要对日期类型的值进行运算
                        cons_key = CalculateDate().test_get_day_by_num(operand1,'-',operand2)
                    else:  # 否则直接进行数值计算
                        cons_key = str(int(operand1) - int(operand2))
                elif '+' in cons_key:
                    operand1 = (cons_key.split('+')[0]).replace(key,cons_dict[key])
                    operand2=cons_key.split('+')[1]
                    if re.search(reg, operand1):
                        cons_key = CalculateDate().test_get_day_by_num(operand1,'+',operand2)
                    else:
                        cons_key = str(int(operand1) + int(operand2))
                else:
                    cons_key = cons_key.replace(key,cons_dict[key])
                break
        return cons_key

    def __test_query_from_sqlitedb_cons(self, db_file_path, functionID, suiteName):
        dbconn = test_conn_sqlite_db(db_file_path)
        cursor = dbconn.cursor()
        tableName ='CONSTANT'


if __name__ == "__main__":
    sqlliteobj = SQLiteOpetating()
    sqlliteobj.test_query_from_sqlitedb1('F:\\sqllitetest\\IUMP.db')
